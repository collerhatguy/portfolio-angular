import Article from "./Article"
const articles: Article[] = [
    { 
        header: "Angular vs React", 
        date: "July 29th, 2021",
        paragraphs: [
            "   When I first jumped from React to Angular I thought Angular was just a poor man's React. I thought it was ridiculus how Angular had 4 files for every component. The ngFor loop didn't feel as inuitive as the map method of react and I was unfamiliar with typescript. Now having built this website you are reading this on with Angular and getting to know the framework better over he course of a couple dates, I now know that Angular is far from the bargain bin version of React. Tihs shouldn't have surprised me since when I first started using React I thought it was clunky and counterintuitive relative to vanilla js, and now I use it for almost every project. 'But Jacob' I hear you saying, 'why aren't you using one for every project for the sake of simplicity? Wouldn't that make things easier?'. No dear reader, for neither framework is strictly better than the other at everything and so they both are best used for specific projects. That's why I am going to go over the pros and cons of each so that YOU know which is best for your needs.",
            "   Scalability is important to a truely great developer. An ametuer developer writes one and done code that solves whatever immediate problem the project is facing in the moment and then forgets about it. Then a week later he/she returns to his code and thinks 'God I cant read this' or 'Oh great now I have to copy and paste this chunk of code over and over' or the worst possible outcome 'There is an error going on somewhere in this 30 page chunk of code and I have to debug the whole thing'. Noone wants to be in that situation and frameworks are supposed to be, at least a partialy, a remedy for that. Both React and Angular feature reusable components that make displaying chunks of data to the DOM easier and simpler compared to vanilla js. However Angular makes component creation and management easier in a multiude of ways. First of all the ngIf attribute makes conditional rendering easier in angular as it takes up less space then the curly bracket combined with ternary operator. Rather than wrapping the whole components with ternary operators that have to end with an ugly ': null' we can relegate all of that to an ngIf right at the start.",
            "   Angular also scales its components better in regards to styles as each component gets its own style sheet that can exclusively select elements related to it repective component. That means that you can reuse slectors like '.card' in your components stylesheet and it will exclusively effect that component. That saves you the headache of having to come up with an ultra specific name for a class like '.article-header-container' and just use the h2 tag with no furhter specificity. This can somtimes be frustrating for when you want to use global styles like a css reset, but there is still a global stylsheet that effects all components in the root of the src directory. Reacts closest competition to that would be styled-components which have there own set of strengths: mainly that they handle theme management alot easier. However it inevitebly becomes a headache when it comes time to figure out why that one peculiar div is acting the way it is, and so you have to figure out if there is anything selecting it by accident and then figure out how to resolve the specificity battle waging under the surface."
        ]
    },
    {
        header: "GraphQL vs REST",
        date: "December 16th, 2021",
        paragraphs: [
            "  I just spent 2 weeks or so learning GraphQL. GraphQL is an amazing technology and I am here to tell you about my experience with it and the benefits of using it as opposed to a traditional REST API.",
            "  The first thing you would notice about GraphQL, apon trying it out, is that it takes a little longer to get a working version of it up and running because of it's type checking system. That is usually the norm with type checking software; it requires a but of more energy at the beggining and saves energy toward the late stages of develpment via correcting data type errors. The way GraphQL simplifies work though, is through custom resolve functions. The way these resolve functions work is that they take the parent properties of the object that they are in, followed by the arguments passed in through the API call, and finally the context object that usualy has any modals attached to it.", 
            "  Using those three things the developer can write a function that dynamically retrieves information related to another piece of information, based on the properties of passed into the resolver. This is espacially useful when working with relational databases: like retrieving the number of likes assoiciated with a post, the books associate with an author, or the students of a teacher. If you've ever worked with SQL queries before, then this makes it so that left and right joins are almost always unnecessary, since that can be substituted with different resolvers (it's far simpler).",
            "  In practice, when you try to query for one of these object types you must specify what properties of each object that you need at the moment, and then what GraphQL returns to you is based on what you returned for the associated resolver. That ensures that the filtering and querying process are combined and that the frontend only ever gets data that is requested. It's a great quailty of life change for full stack developers that may make a query to get a large set of data, only to use a small portion of it.",
            "  That's all well and good but at this point you might be wondering, 'Why not use GraphQL all the time if it really is that easy?'. Well there are 2 things that GraphQL doesn't seem to do well, in my own opinon. The first is handling middleware functions. For REST API's, middleware functions can be placed in between the pathname and the router to be called whenever that set of endpoints needs that specific piece of middleware. I GraphQL, you would need to call that middleware individually for every resolver that needed that middleware unless you were sure that a parent resolver already called it. You can't be sure of that though because of the loopy nature by which you can query that data.",
            "  That second thing that GraphQL seems to struggle with is a way to order the data of a list. When querying for a list, it is onely possible to define the individual properties of teh objects in the list and not the order of the list itself. If you would like to do that then a propery on the list must be defined to signify an order and then the frontend must sort the data basd on that property. This could be a problem if you are like me and wanted to paginate the data but also sort it to get the top ten most liked posts, only to realize that you would have to refactor a bunch of code to get that to work.",
            "  All in all, I still think that GraphQL is perfect for Full-Stack Developers that need to quickly hop between the frontend and backend. It handles relational data incredibly well and makes it easy for frontend developers to get the exact cut of meat that they want, down to the rarity.",
        ]
    }
]
export default articles;